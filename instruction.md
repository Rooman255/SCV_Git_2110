![Logo](logo.jpg)
# Работа с Git

## 1. Проверка наличия установленного Git
в терминале выполнить команду `git version`.
Если Git установлен появится сообщение с информанией версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с сайта 
https://git-scm.com/downloads
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовинии Git необходимо представиться. Для этого ввести в терминале две команды:
```
git config --global user.name "Имя пользователя"
git config --global user.emall "почта пользователя"
```
## 4. Инициализация репозитория
Получить репозиторий можно двумя способами:
1. В терминале переходим к папке, в которой хотим создать репозиторий. Выполняем команду:
```
git init
```
2. Клонировать существующий репозиторий Git из любого места. Сделать можно так:
```
git clone <адрес репозитория>
```

## 5. Запись изменений в репозиторий

Каждый файл в рабочей папке (репозитория) может находится в одном из двух состояний: под версионным контролем(отслеживаемым) и нет(неотслеживаемым).

Отслеживаемые файлы могут быть измененными, неизмененными или подготовленными к комиту.

Команда `git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git.

Для добавления изменений из рабочего каталога в раздел проиндексированных файлов используем команду `git add`.
Она сообщает Git, что вы хотите включить изменения в конкретном файле в следующий коммит.

Команда `git commit` делает для проекта снимок текущего состояния изменений, добавленных в раздел проиндексированных файлов. Такие подтвержденные снимки состояния можно рассматривать как «безопасные» версии проекта — Git не будет их менять, пока вы явным образом не попросите об этом.

Сравнение — это функция, анализирующая два входных набора данных и отображающая различия между ними. `git diff` представляет собой многоцелевую команду Git, которая инициирует функцию сравнения источников данных Git — коммитов, веток, файлов и т. д.

## 6. Истории коммитов

Для просмотра истории коммитов используем команду `git log`.

Данная команда перечисляет коммиты с их хэш-кодами, именем и электронной почтой автора, датой создания и сообщением коммита.

## 7. Перемещение между сохранениями
После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду `git checkout`. Команда `git checkout` — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика:
```
git checkout <хэш-код>
```
 Вы можете просматривать файлы, компилировать проект, запускать тесты и даже редактировать файлы, не боясь потерять текущее состояние проекта. Никакие внесенные здесь изменения не будут сохранены в репозитории. Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:
```
git checkout master 
```

## 8. Информация по работе с ветками
Ветка представляет собой отдельное направление разработки. Ветки выступают в качестве абстрактного представления для процесса редактирования/индексации/коммита. Можно рассматривать их как способ запросить новый рабочий каталог, раздел проиндексированных файлов и историю проекта. Новые коммиты записываются в историю текущей ветки, что приводит к образованию развилки в истории проекта.

Команда `git branch` позволяет создавать, просматривать, переименовывать и удалять ветки. Она не дает возможности переключаться между ветками или выполнять слияние разветвленной истории. Именно поэтому команда `git branch` тесно связана с командами `git checkout` и `git merge`.
Для отображения списка веток репозитория используется команда:
```
git branch
```
Для создания новой ветки с именем <ветка> используем кодманду:
```
git branch <ветка>
```
Эта команда не выполняет переключение на эту новую ветку.

Удаление указанной ветки. Это «безопасная» операция, поскольку Git не позволит удалить ветку, если в ней есть неслитые изменения. Для этого используем команду:
```
git branch -d <ветка>
```
Принудительное удаление указанной ветки, даже если в ней есть неслитые изменения. Эта команда используется, если вы хотите навсегда удалить все коммиты, связанные с определенным направлением разработки:
```
git branch -D <ветка>
```
Слияние используется в Git, чтобы собрать воедино разветвленную историю. Команда `git merge` выполняет слияние отдельных направлений разработки, созданных с помощью команды `git branch`, в единую ветку:
```
git merge <ветка>
```
Обратите внимание: `git merge` выполняет слияние в текущую ветку, в то время как целевая ветка остается без изменений. Поэтому команда `git merge` часто используется в сочетании с командами `git checkout` (для выбора текущей ветки) и `git branch` -d (для удаления устаревшей целевой ветки). Создавая коммит слияния, Git попытается автоматически объединить две истории. Однако если Git обнаружит, что вы изменили одну и ту же часть данных в обеих историях, сделать это автоматически не удастся. Это называется конфликтом управления версиями, и для его разрешения Git потребуются действия пользователя.

Перед слиянием следует предпринять несколько подготовительных действий, чтобы операция прошла без проблем. Выполните команду `git status`. Это позволит убедиться, что `HEAD` указывает на ветку, принимающую результаты слияния. При необходимости выполните команду `git checkout` <принимающая-ветка>, чтобы переключиться на принимающую ветку. После указанных выше действий по подготовке можете приступать к слиянию. Для этого выполните команду `git merge` <название ветки>, где <название ветки> — название ветки, которая будет объединена с принимающей.

При попытке объединить ветки, в которых изменена одна и та же часть того же файла, Git не сможет сделать выбор между версиями. В таком случае операция останавливается прямо перед созданием коммита слияния, чтобы пользователь вручную разрешил конфликты. Преимущество слияния в Git заключается в том, что разрешение конфликтов при слиянии проходит по привычной схеме «редактирование — индексирование — коммит». При обнаружении конфликта выполните команду `git status`, чтобы увидеть, какие файлы необходимо исправить.

Когда Git обнаруживает конфликт в ходе слияния, к затронутым файлам добавляются визуальные индикаторы по обе стороны проблемного содержимого: <<<<<<<, ======= и >>>>>>>. Чтобы обнаружить конфликты, попробуйте поискать в проекте эти индикаторы.

Обычно содержимое перед отметкой ======= относится к принимающей ветке, а все, что указано после нее, — к ветке, для которой выполняется слияние. После обнаружения конфликтующих участков кода вы можете исправить их по своему усмотрению. Когда вы будете готовы завершить слияние, выполните команду `git add` для конфликтующего файла или файлов — так вы сообщите Git, что конфликт разрешен. Затем выполните обычную команду `git commit`, чтобы создать коммит слияния.

## 9. Игнорирование файлов

Неотслеживаемые файлы обычно делятся на две категории. Это либо файлы, которые только что были добавлены в проект и еще не были зафиксированы, либо скомпилированные двоичные файлы, такие как .pyc, .obj, .exe, и т. д.

По этой причине Git позволяет полностью игнорировать файлы, помещая пути в специальный файл с именем **.gitignore**. Любые файлы, которые вы хотите игнорировать, должны быть включены в отдельную строку, а символ * можно использовать в качестве подстановочного знака. Например, добавление следующего в **.gitignore** файл в корне вашего проекта предотвратит появление скомпилированных модулей в `git status`:
```
*.jpg
*.png
```
## 10. Работа с удаленными репозиториями

Прежде всего вам необходимо зарегистрироваться на GitHub, но это довольно тривиальный процесс, так что его мы здесь опустим. После регистрации вы попадете на главную страницу. На ней будут отображаться действия людей, на которых вы подписались и обновления в репозиториях, которые вы добавили в избранное.

Чтобы создать свой репозиторий, нажмите на зеленую кнопку **New**.

Перед вами откроется страница создания репозитория. Давайте разберем, что за поля нам предлагают заполнить.

1. Итак, первое поле Repository name – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
2. Второе поле – Description – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
3. Затем вы можете выбрать, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.
4. Последние три поля предлагают нам добавить, соответственно, README-файл, .gitignore файл и выбрать лицензию для нашего проекта.

В верхнем меню мы видим 9 разных вкладок. Давайте разберем их по порядку.

1. Вкладка Code. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла README (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.
2. Вкладка Issues. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.
3. Вкладка Pull-requests. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями.
4. Вкладки Actions и Project относятся скорее к системе CI/CDI, которую предоставляет GitHub, в этом курсе мы не будем затрагивать их.
5. Вкладка Wiki открывает вам доступ к созданию и размещению документации о собственном проекте.
6. На вкладке Security содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на GitHub.
7. Вкладка Insight содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.
8. Последняя вкладка – Settings. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

В системе SVN используется единый централизованный репозиторий, служащий центром связи для разработчиков. Совместная работа ведется путем передачи наборов изменений между рабочими копиями разработчиков и центральным репозиторием. Однако модель распределенной совместной работы в Git предполагает, что каждый разработчик использует собственную копию репозитория со своей локальной историей и структурой веток. Обычно пользователи делятся не отдельными наборами изменений, а сериями коммитов. Вместо того чтобы выполнять коммит одного набора изменений из рабочей копии в центральный репозиторий, Git позволяет передавать между репозиториями целые ветки.

Команда `git remote` позволяет создавать, просматривать и удалять подключения к другим репозиториям. Удаленные подключения скорее похожи на закладки, чем на прямые ссылки на другие репозитории. Они служат удобными именами, с помощью которых можно сослаться на не очень удобный URL-адрес, а не предоставляют доступ к другому репозиторию в режиме реального времени.

Для просмотра текущего состояния списка удаленных подключений используются следующие команды.
```
git remote
```
Список ваших удаленных подключений к другим репозиториям.
```
git remote -v
```
Аналогично команде выше, но включает URL-адрес каждого подключения.

Иногда возникает необходимость **забыть** удаленный репозиторий. Для этого существует команда `git remote remove`.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда `git clone`.

Чтобы получить ссылку на удаленный репозиторий нужно нажать на зеленую кнопку **Code** на главной странице репозитория на GitHub.

Заметьте, что клонирование по https возможно вообще всегда, а по ssh – нет. Чтобы клонировать репозитории по ssh, нужно, чтобы владелец удаленного репозитория на GitHub добавил к себе публичный ssh-ключ из пары, в то время, как секретный ssh-ключ от той же пары хранится у вас на компьютере, с которого вы выполняете git clone. Таким образом, если вы настроили ssh в своем аккаунте, то вы сможете беспрепятственно клонировать свои репозитории и по https, и по ssh. Но если вы пытаетесь клонировать чужой репозиторий по ssh, то скорее всего получите ошибку доступа.

Теперь, когда мы научились подключать удаленный репозиторий к локальному и клонировать его к себе на компьютер, пора узнать, как же получить изменения из удаленного репозитория. Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда `git fetch`.

Команда `git fetch` используется для синхронизации локальных ссылочных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет.
Чтобы синхронизировать локальную рабочую копию с удаленным репозиторием, нужно слить удаленные ветки в локальные. Сделать это можно уже знакомой командой `git merge`.

Связкой `git fetch` && `git merge` мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она `git pull`.

Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. Для этого в Git существует команда `git push`.

Давайте более подробно разберем, как работает эта команда. Допустим, мы выполнили `git push origin develop` в нашем локальном репозитории. Возможны три варианта развития событий:
1. Если изменения с нашей ветки можно слить с удаленной веткой в режиме fast-forward, то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.
2. Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме fast-forward выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.
3. Но если вы вдруг передали флаг `--force`, то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага – `--force-with-lease`. Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка. Таким образом, вы не попадете в ситуацию, когда вы случайно удалили чужой коммит.

## 11. Создание форка репозитория на GitHub. Пулл-реквесты.

Итак, одной из самых важных частей GitHub является создание форков.

Форк (от англ. fork – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.

Пулл-реквест (от англ. pull-request – запрос pull) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный code-review с указанием всех неточностей.

Теперь давайте рассмотрим пайплайн контрибуции (англ. contribution – внесение вклада) на примере реального репозитория. То есть научимся вносить свой вклад в разработку проектов с открытым исходным кодом на GitHub:

1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку **Fork**, как показано на картинке. После этого Git создаст точную копию этого репозитория в вашем аккаунте.
2. Клонируем репозиторий к себе на компьютер командой `git clone`. Создадим файл README.md с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.
3. Сделаем коммит и выполним `git push`, чтобы загрузить наши изменения в удаленный репозиторий.
4. Теперь GitHub подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.
5. Нажимаем на кнопку **Compare** на подсказке GitHub, либо переходим на вкладку **Pull Requests** и нажимаем **New pull request**.
6. Перед нами откроется страница создания пулл-реквеста. Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: одну в исходном репозитории, на нее будут залиты наши изменения, вторую – в нашем репозитории, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку **Create pull request**.
7. Теперь мы попадаем на страницу описания наших изменений. Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. Сообщение, которое оставили мы, видно на картинке. Оно отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку **Create pull request**.
8. Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.